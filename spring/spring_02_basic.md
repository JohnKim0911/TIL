# (복습) 스프링 핵심 원리 - 기본편

- 김영한의 스프링 완전 정복 로드맵
    - 2편) 스프링 핵심 원리 - 기본편

|    | 제목                                                            | 강의 분량     | 교재 분량 (페이지) | 복습일        |
|----|---------------------------------------------------------------|-----------|-------------|------------|
| 1  | [강의 소개](#1-강의-소개)                                             | 4분        | 3           | 2024.12.16 |
| 2  | [객체 지향 설계와 스프링](#2-객체-지향-설계와-스프링)                             | 1시간 16분   | 65          | 2024.12.17 |
| 3  | [스프링 핵심 원리 이해1 - 예제 만들기](#3-스프링-핵심-원리-이해1---예제-만들기)           | 1시간 1분    |             |            |
| 4  | [스프링 핵심 원리 이해2 - 객체 지향 원리 적용](#4-스프링-핵심-원리-이해2---객체-지향-원리-적용) | 1시간 38분   |             |            |
| 5  | [스프링 컨테이너와 스프링 빈](#5-스프링-컨테이너와-스프링-빈)                         | 1시간 19분   |             |            |
| 6  | [싱글톤 컨테이너](#6-싱글톤-컨테이너)                                       | 1시간 15분   |             |            |
| 7  | [컴포넌트 스캔](#7-컴포넌트-스캔)                                         | 51분       |             |            |
| 8  | [의존관계 자동 주입](#8-의존관계-자동-주입)                                   | 1시간 53분   |             |            |
| 9  | [빈 생명주기 콜백](#9-빈-생명주기-콜백)                                     | 35분       |             |            |
| 10 | [빈 스코프](#10-빈-스코프)                                            | 1시간 44분   |             |            |
| 11 | [다음으로](#11-다음으로)                                              | 25분       |             |            |
|    |                                                               | 총 12시간 5분 |             |            |

## 1. 강의 소개

- 강의 소개 페이지: https://inf.run/kCYMv

- 아래 내용은...
  - 강의 내용을 개인적으로 복습하고자 정리하였습니다.
    - 제 기억을 살리기 위한 용도이다보니, 아래 글만으로는 이해가 어려울 수 있습니다.
      - 필요하시다면, 위 강의를 직접 수강하시는 것을 추천드립니다.
    - 방식:
      - 강의를 들으면서 코드를 직접 치고,
      - 강의가 끝나면 다시 교재를 보면서 중요 내용 위주로 정리하였습니다.
  - 유료 강의이므로, 실제 작성한 전체 코드는 비공개 합니다. (저작권...)
    - 비공개 레포지토리: 
      - 링크가 있긴하지만, 저만 볼 수 있습니다. (404 error 뜨는게 정상)

## 2. 객체 지향 설계와 스프링

> 참고) <2. 객체 지향 설계와 스프링>는 강의에 코드 작성없이, 이론적인 내용만 다루었다.

### 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

- 옛날 옛적에... 자바에서 만든 `EJB` 가 있었다. (`EJB`: Enterprise Java Beans)
  - `EJB` 지옥...
    - 개발자가 쓰기 어려웠다.
    - `"순수한 자바로 돌아가자"`는 말도 있었다.
      - `POJO`라는 용어 등장. (`POJO`: Plain Old Java Object)

- `EJB`쓰던 개발자가 답답해서 오픈소스로 직접 만들었다.
  - 스프링
    - `EJB` 컨테이너 대체
    - 현재 사실상 표준 기술
  - 하이버네이트
    - `EJB` 엔티티빈 기술을 대체
    - 자바가 하이버네이트를 만든 개발자를 모셔와서 자바 표준(`JPA`)을 만들었다. (`JPA`: Java Persistence API)
    - `JPA`가 인터페이스고, `하이버네이트`가 구현체다.
        
      ![JPA](https://github.com/user-attachments/assets/12e797d2-094d-4fb7-8c6c-6ae40a5064dc)

- 스프링 역사
  - 2002년, `로드 존슨`이 책 출간하면서 시작.
    - `EJB`의 문제점 지적
    - `EJB` 없이도 충분히 고품질의 확장 가능한 애플리케이션을 개발할 수 있음을 보여주고, 30,000 라인 이상의 기반 기술을 예제 코드로 선보임
    - 여기에 지금의 스프링 핵심 개념과 기반 코드가 들어가 있음
      - `BeanFactory`, `ApplicationContext`, `POJO`, `제어의 역전`, `의존관계 주입`
    - 책이 유명해지고, 개발자들이 책의 예제 코드를 프로젝트에 사용
  - 책 출간 직후,
    - `Juergen Hoeller(유겐 휠러)`, `Yann Caro(얀 카로프)`가 `로드 존슨`에게 오픈소스 프로젝트를 제안
    - 스프링의 핵심 코드의 상당수는 `유겐 휠러`가 지금도 개발
    - `스프링 이름`은 전통적인 `J2EE(EJB)`라는 `겨울을 넘어 새로운 시작`이라는 뜻으로 지음

  - 릴리즈
    - 2003년 스프링 프레임워크 1.0 출시 - XML
    - 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
    - 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
    - 2013년 스프링 프레임워크 4.0 출시 - 자바8
    - 2014년 스프링 부트 1.0 출시
    - 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원
    - 2020년 9월 현재 스프링 프레임워크 5.2.x, 스프링 부트 2.3.x

### 스프링이란?

- 스프링 생태계

  ![스프링 생태계](https://github.com/user-attachments/assets/23b5e6ba-203a-4233-8453-e85223a4f07e)

  - https://spring.io/projects 에서 더 자세히 확인할 수 있다. (많다...)

- `스프링 프레임워크`
  - 핵심 기술: `스프링 DI 컨테이너`, `AOP`, `이벤트`, 기타
  - 웹 기술: `스프링 MVC`, `스프링 WebFlux`
  - 데이터 접근 기술: `트랜잭션`, `JDBC`, `ORM` 지원, `XML` 지원
  - 기술 통합: `캐시`, `이메일`, `원격접근`, `스케줄링`
  - 테스트: 스프링 기반 테스트 지원
  - 언어: 코틀린, 그루비
  - 최근에는 `스프링 부트`를 통해서 스프링 프레임워크의 기술들을 편리하게 사용
    - 예전에는 스프링의 반은 설정이다 하는 말이 있었다... 설정하다가 포기할 수 있음... `스프링 부트`를 쓰자.

- `스프링 부트`
  - `스프링`을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
  - 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
  - `Tomcat` 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
    - 예전엔 스프링에서 빌드해서 `war`파일을 만들고 서버에 밀어넣는 일들을 했었음...
  - 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 스프링과 3rd party(외부) 라이브러리 자동 구성
  - 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
  - 관례에 의한 간결한 설정

- `스프링`은 왜 만들었나?
  - 스프링의 핵심 개념, 컨셉?
    - 핵심이 아닌 것:
      - 웹 애플리케이션 만들고, DB 접근 편리하게 해주는 기술?
      - 전자정부 프레임워크?
      - 웹 서버도 자동으로 띄워주고?
      - 클라우드, 마이크로서비스?
    - 핵심:
      - 스프링은 `자바` 언어 기반의 프레임워크
        - `자바` 언어의 가장 큰 특징 - `객체 지향` 언어
      - 스프링은 `객체 지향` 언어가 가진 강력한 특징을 살려내는 프레임워크
      - 스프링은 좋은 `객체 지향` 애플리케이션을 개발할 수 있게 도와주는 프레임워크

### 좋은 객체 지향 프로그래밍이란?

- 이전에 `김영한의 실전 자바 - 기본편`에서 다뤘던 `다형성과 설계`의 내용과 동일한 내용을 다뤘다.
  - 이번 강의에선 코드까지 직접 치진 않았고, 이론 위주로 설명만 하였다.
  - (이전에 정리해뒀던 내용) :
    - https://github.com/JohnKim0911/TIL/blob/master/java/java_02_basic.md#13-%EB%8B%A4%ED%98%95%EC%84%B1%EA%B3%BC-%EC%84%A4%EA%B3%84
  - 요점
    - `객체지향 프로그래밍` 특징 4가지:
      - `추상화`, `캡슐화`, `상속`, `다형성`
      - 이 중에서 `다형성`이 제일 중요하다.
    - `다형성`의 본질
      - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
        - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
      - 역할과 구현을 분리
    - `스프링`은 `다형성`을 극대화해서 이용할 수 있게 도와준다.

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

-  면접에 나올 수 있는 질문이다.

- `클린코드`로 유명한 `로버트 마틴`이 좋은 객체 지향 설계의 5가지 원칙을 정리하였다.
  - 이전 부터 있던 내용인데, 이 분이 잘 정리했다.

- `SOLID`
  - `SRP`: `단일 책임 원칙` (Single Responsibility Principle)
  - `OCP`: `개방-폐쇄 원칙`⭐ (Open/closed principle) --> 이게 가장 중요하다.
  - `LSP`: `리스코프 치환 원칙` (Liskov substitution principle)
  - `ISP`: `인터페이스 분리 원칙` (Interface segregation principle)
  - `DIP`: `의존관계 역전 원칙` (Dependency inversion principle)

- `SRP`, 단일 책임 원칙
  - **한 클래스는 하나의 책임만** 가져야 한다.
  - 하나의 책임이라는 것은 모호한데, 중요한 기준은 변경이다.
    - 변경이 있을 때 파급 효과가 적으면, 단일 책임 원칙을 잘 따른 것.

- `OCP`, 개방-폐쇄 원칙
  - 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
  - 다형성 생각해보면 된다.
    - 역할과 구현의 분리
    - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
  - 문제점 ⭐
    - 구현 객체를 변경하려면, 클라이언트 코드를 변경해야 한다.
      - 변경이 없을 줄 알았지만, 결국 변경해야한다.
      - `MemberService` 클라이언트가 구현 클래스를 직접 선택
        - `MemberRepository m = new MemoryMemberRepository();` //기존 코드
        - `MemberRepository m = new JdbcMemberRepository();` //변경 코드
    - 분명 다형성을 사용했지만 `OCP` 원칙을 지킬 수 없다.
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. ⭐

- `LSP`, 리스코프 치환 원칙
  - 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.
    - 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
  - 예시) 
    - 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 `LSP` 위반, 느리더라도 앞으로 가야함.

- `ISP`, 인터페이스 분리 원칙
  - 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 즉, 인터페이스를 작게 분리하면 더 좋다.
  - 예시)
    - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
    - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
  - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

- `DIP`, 의존관계 역전 원칙
  - "추상화에 의존해야지, 구체화에 의존하면 안된다."
    - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
  - 문제점 ⭐
    - `OCP`에서 설명한 `MemberService`는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.
      - `MemberService` 클라이언트가 구현 클래스를 직접 선택
        - `MemberRepository m = new MemoryMemberRepository();`
    - `DIP` 위반!

- 정리 ⭐
  - 객체 지향의 핵심은 `다형성`
  - 근데 `다형성` 만으로는...
    - 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
    - `OCP`, `DIP`를 지킬 수 없다.
  - 뭔가 더 필요하다.

### 객체 지향 설계와 스프링

- 스프링은 다음 기술로 `다형성` + `OCP`, `DIP`를 가능하게 지원한다. ⭐
  - `DI`: `의존관계, 의존성 주입` (DI: Dependency Injection)
  - `DI 컨테이너` 제공

- 스프링이 없던 시절...
  - 옛날 어떤 개발자가 좋은 `객체 지향` 개발을 하려고 `OCP`, `DIP` 원칙을 지키면서 개발을 해보니, 너무 할일이 많았다. 배보다 배꼽이 크다. 그래서 `프레임워크`로 만들어버렸다.
  - 순수하게 자바로 `OCP`, `DIP` 원칙들을 지키면서 개발을 해보면, 결국 `스프링 프레임워크`를 만들게 된다. (더 정확히는 DI 컨테이너)

- 정리
  - 모든 설계에 역할과 구현을 분리하자.
  - 이상적으로는 모든 설계에 인터페이스를 부여하자.
    - 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
      - 개발자가 코드를 한번 더 타고 들어가야한다. 
        - 코드를 타고 들어갈 때, 구현 클래스를 바로 보지 못하고, 인터페이스 코드가 보여지게 됨.
      - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

## 3. 스프링 핵심 원리 이해1 - 예제 만들기

## 4. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

## 5. 스프링 컨테이너와 스프링 빈

## 6. 싱글톤 컨테이너

## 7. 컴포넌트 스캔

## 8. 의존관계 자동 주입

## 9. 빈 생명주기 콜백

## 10. 빈 스코프

## 11. 다음으로