# (복습) 스프링 핵심 원리 - 기본편 (요약)

## 1. 서론

### ✔️ 서론

- 이 글의 목적
  - 기존에 정리했던 내용: 
    - [(복습) 스프링 핵심 원리 - 기본편](spring_02_basic.md)
  - 위 내용을 한번 더 요약하면서 전체적인 흐름을 복습하고자 함.
    - 양이 방대하고 아직 내용이 내게 낯설어서 한눈에 안들어온다...
    - 큰 흐름을 잡고, 디테일한 것은 필요할 때 다시 찾아봐야겠다.

### ✔️ 목차

1. 객체 지향 설계와 스프링 
2. 스프링 핵심 원리 이해 
3. 스프링 컨테이너와 스프링 빈 
4. 싱글톤 컨테이너 
5. 컴포넌트 스캔 
6. 의존관계 자동 주입 
7. 빈 생명주기 콜백 
8. 빈 스코프

## 1. 객체 지향 설계와 스프링

### ✔️ 객체 지향 프로그래밍(OOP)

- `OOP`의 4가지 특징 : `추상화`, `캡슐화`, `상속`, `다형성`
  - `다형성`이 제일 중요하다.

### ✔️ 객체 지향 설계의 5가지 원칙(SOLID)

- `SRP`: `단일 책임 원칙` (Single Responsibility Principle) ⭐
  - 한 클래스는 하나의 책임만 가져야 한다.
- `OCP`: `개방-폐쇄 원칙` (Open/closed principle) ⭐
  - 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
- `LSP`: `리스코프 치환 원칙` (Liskov substitution principle)
  - 하위 클래스는 상위 인터페이스 규약을 지켜야 한다.
- `ISP`: `인터페이스 분리 원칙` (Interface segregation principle)
  - 인터페이스를 작게 분리하면 더 좋다.
- `DIP`: `의존관계 역전 원칙` (Dependency inversion principle) ⭐
  - 구체화가 아닌, 추상화에 의존해야 한다.

### ✔️ 왜 스프링?

- `자바`만으로는 `객체지향`의 핵심인 `다형성`을 구현하기에 `한계`가 있다.
  - 구현 객체를 변경할때 클라이언트의 코드도 함께 변경하게됨. (`OCP`,`DIP` 위반)
    - 예) `MemberService` 클라이언트가 구현 클래스를 직접 선택
      - `MemberRepository m = new MemoryMemberRepository();`
- `스프링`으로는 가능!
  - `스프링`은 `다형성`을 극대화해서 이용할 수 있게 도와준다.

## 2. 스프링 핵심 원리 이해

### ✔️ AppConfig (설정 정보)

- `AppConfig`: 애플리케이션의 전체 동작 방식을 구성하는 설정 클래스.
  - `공연`을 준비할 때, `배우`가 `상대방 배우`를 정하지 않는다.
    - `배우`는 배역을 수행하는 것에 집중 해야하고,
    - `공연기획자`가 공연을 구성하고, 역할에 맞는 배우를 지정한다.
  - `애플리케이션`에서 `AppConfig`가 `공연기획자` 역할을 한다.
    - `AppConfig`에서 구현 객체를 생성하고, 연결한다.
- `AppConfig`를 별도로 둔 덕분에 `OCP`,`DIP`, `SRP`를 지킬 수 있다.

> `AppConfig`는 임의로 지정한 단순 클래스 이름이다.

### ✔️ IoC (Inversion of Control, 제어의 역전)

- 프로그램의 `제어 흐름`을 `직접 제어`하는 것이 아니라 `외부에서 관리`하는 것.
  - `이전`: `직접 제어`
    - `구현 객체`가 프로그램의 제어 흐름을 스스로 조종했다.
  - `AppConfig` 등장 이후: `외부에서 관리`
    - `AppConfig`가 제어의 흐름을 가져간다.
    - `구현 객체`는 자신의 로직을 실행하는 역할만 담당한다.

- `라이브러리` vs `프레임워크`
  - `라이브러리` : 내가 작성한 코드가 직접 제어의 흐름을 담당. (`주도권을 내가 가짐`)
  - `프레임워크` : 내가 작성한 코드를 프레임워크가 제어하고, 대신 실행. (`주도권을 프레임워크가 가짐`)

### ✔️ DI (Dependency Injection, 의존관계 주입)

- `런타임`에 `외부`에서 `구현 객체`를 생성하고 `클라이언트`에 전달해서, `클라이언트`와 `서버`의 실제 `의존관계`가 연결 되는 것.
  - (`외부` --> `클라이언트` --> `서버`)

### ✔️ DI 컨테이너 (== AppConfig)

- `AppConfig`처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 `IoC 컨테이너` 또는 `DI 컨테이너`라 한다.
  - 최근에는 주로 `DI 컨테이너`라 한다.

## 3. 스프링 컨테이너와 스프링 빈

### ✔️ 스프링 컨테이너, 스프링 빈

- `ApplicationContext`를 `스프링 컨테이너`라 한다.
- `스프링 컨테이너`는 `@Configuration`이 붙은 `AppConfig`를 설정(구성) 정보로 사용한다.
  - 여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 `스프링 컨테이너`에 등록한다.
  - 이렇게 `스프링 컨테이너`에 등록된 객체를 `스프링 빈`이라 한다.
  - `스프링 빈`은 `@Bean`이 붙은 메서드의 명을 `스프링 빈`의 이름으로 사용한다.
- `스프링 컨테이너`를 통해서 필요한 `스프링 빈`(객체)를 찾아야 한다.
  - `스프링 빈`은 `applicationContext.getBean()` 메서드를 사용해서 찾을 수 있다.

## 4. 싱글톤 컨테이너

### ✔️ 싱글톤 패턴

- `클래스`의 `인스턴스`가 `딱 1개만 생성`되는 것을 보장하는 `디자인 패턴`이다.
  - `싱글톤 패턴`을 적용하면, 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.
- `자바`로만 `싱글톤 패턴`을 구현하면 여러 `문제점`들이 있다.
  - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
  - 테스트하기 어렵다.
  - 내부 속성을 변경하거나 초기화 하기 어렵다.
  - private 생성자로 자식 클래스를 만들기 어렵다.
- `스프링`의 `스프링 컨테이너`는 이 문제점들을 `해결`한다.

### ✔️ 싱글톤 컨테이너

- `스프링 컨테이너`는 `싱글톤 패턴`의 문제점을 해결하면서, 객체 인스턴스를 `싱글톤`(1개만 생성)으로 관리한다.
  - `스프링 빈`이 바로 `싱글톤`으로 관리되는 `빈`이다.

### ✔️ 싱글톤 방식의 주의점

- `싱글톤` 방식은 `여러 클라이언트`가 `하나의 같은 객체 인스턴스`를 공유하기 때문에 정말 `위험`하다.
- `스프링 빈`의 `필드`에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!!

## 5. 컴포넌트 스캔

### ✔️ 컴포넌트 스캔

- `스프링`은 `설정 정보(AppConfig)`가 없어도 `자동으로 스프링 빈을 등록`하는 `컴포넌트 스캔` 기능을 제공한다.
  - `@Component` 애노테이션이 붙은 클래스를 스캔해서 `스프링 빈`으로 등록.

## 6. 의존관계 자동 주입

### ✔️ 의존관계 자동 주입

- `스프링`은  `의존관계도 자동으로 주입`하는 `@Autowired`라는 기능도 제공한다.

- `의존관계 주입`은 크게 4가지 방법이 있다.
  - `생성자 주입` // 이거 쓰자!! ✅
  - `수정자 주입`(`setter 주입`) // 가끔 필요할때만 사용하자.
  - `필드 주입` // 사용 x
  - `일반 메서드 주입` // 사용 x

### ✔️ 롬복(Lombok)

- 막상 개발을 해보면, 대부분이 다 `불변`이다.
  - 필드에 `final` 키워드를 사용하고, `생성자`도 만들어야 하고, `주입 받은 값을 대입하는 코드`도 만들어야 한다.
  - 반복적인 코드 편하게 작성하려면? `롬복` 사용!
- `Lombok`을 사용하면, 적용한 `애노테이션`에 따라서 해당 기능을 자동으로 만들어준다. 
  - `@Getter`
  - `@Setter`
  - `@NoArgsConstructor`: 생성자
  - `@ToString`
  - `@RequiredArgsConstructor`: 롬복이 `final`로 되어있는 필드를 보고 자동으로 생성자를 만들어준다.
- 실무에서 많이 쓴다!!
- 사용하려면, `인텔리제이`에 롬복 설치하고, `build.gradle`에 라이브러리 & 환경 추가 해야한다.

### ️✔️ 조회 대상 빈이 2개 이상일 때 해결 방법

- `@Autowired` 매칭 우선순위 정리
  - 1순위) 타입 매칭
  - 2순위) 타입 매칭의 결과가 2개 이상일 때, 필드 명 & 파라미터 명으로 빈 이름 매칭

- 조회 대상 빈이 2개 이상이면 에러가 발생한다. (`NoUniqueBeanDefinitionException`)

- 해결 방법
  - `@Autowired` 필드 명 매칭 // 번거롭다.
  - `@Qualifier` // 특별한 경우에 쓴다.
  - `@Primary` // 주로 이거 쓴다. ✅

- 우선순위
  - `@Primary`보다 `@Qualifier`가 우선순위가 높다.
  - 자주 사용하는 곳엔 `@primary`를 쓰고, 특별한곳에 `@Qualifier`를 쓰면된다.

- `@Qualifier`은 대신 `애노테이션 직접 만들어서 사용`할 수도 있다.
  - `@Qualifier`은 문자열을 사용하기 때문에 컴파일시 타입체크가 안됨.

### ️✔️ 자동 빈 등록 vs 수동 빈 등록

- `자동 빈 등록`을 쓰자. 특별한 곳만 `수동 빈 등록` 사용.
  - 자동 빈 등록: `업무 로직 빈`에 사용
    - 예) `컨트롤러`, `서비스`, `리포지토리`...
  - 수동 빈 등록: `기술 지원 빈`에 사용. 혹은 `다형성`으로 구조를 파악하기 어려운 경우
    - 예) `기술적인 문제`나 `공통 관심사(AOP)` 처리...
    - 설정 정보에 한눈에 딱 보이게!

## 7. 빈 생명주기 콜백

### ✔️ 초기화 콜백, 소멸전 콜백

- `초기화 콜백`: `빈이 생성`되고, 빈의 `의존관계 주입이 완료된 후` 호출
- `소멸전 콜백`: `빈이 소멸되기 직전`에 호출

### ✔️ 스프링 빈의 이벤트 라이프사이클

- 스프링 컨테이너 생성 ➡️ 스프링 빈 생성 ➡️ 의존관계 주입 ➡️ `초기화 콜백` ➡️ 사용 ➡️ `소멸전 콜백` ➡️ 스프링 종료

### ✔️ 빈 생명주기 콜백

- `스프링`은 크게 3가지 방법으로 `빈 생명주기 콜백`을 지원한다.
  - `InitializingBean`,` DisposableBean` 인터페이션 구현 // 안쓴다.
  - `@Bean(initMethod = "init", destroyMethod = "close")` // 아래것들을 못쓸때 사용 (외부 라이브러리)
  - `@PostConstruct`, `@PreDestroy` // 이거 쓰자! ✅

## 8. 빈 스코프

스코프는 빈이 존재할 수 있는 범위를 뜻한다. 

### ✔️ 빈 스코프 종류

- `스프링`은 다음과 같은 다양한 스코프를 지원한다.
  - `싱글톤`: 기본 스코프. `스프링 컨테이너의 시작과 종료까지` 유지되는 가장 넓은 범위의 스코프이다.
  - `프로토타입`: `스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여`하고, 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
  - `웹 관련 스코프`
    - `request`: `웹 요청`이 들어오고 나갈때 까지 유지되는 스코프이다.
    - `session`: `웹 세션`이 생성되고 종료될 때 까지 유지되는 스코프이다.
    - `application`: `웹의 서블릿 컨텍스트와 같은 범위`로 유지되는 스코프이다.

### ✔️ 빈 스코프 지정

- 예시) `@Scope("prototype")`

### ✔️ 싱글톤 스코프 vs 프로토타입 스코프

- `싱글톤 스코프`의 빈을 조회하면, `스프링 컨테이너`는 `항상 같은 인스턴스의 스프링 빈을 반환`한다.
- 반면에 `프로토타입 스코프`를 `스프링 컨테이너`에 조회하면, 스프링 컨테이너는 `항상 새로운 인스턴스를 생성해서 반환`한다.

### ✔️ 싱글톤 빈에서 프로토타입 빈 사용시

- 문제점
  - `싱글톤`과 `프로토타입`을 같이 쓰면, `프로토타입`이 `싱글톤`처럼 사용되어버린다.
    - 어떻게 하면 사용할 때 마다 항상 새로운 `프로토타입 빈`을 생성할 수 있을까?
      - 지정한 `프로토타입 빈`을 컨테이너에서 대신 찾아주는 기능 필요!

- `DL (Dependency Lookup, 의존관계 조회)`
  - 의존관계를 외부에서 주입(DI) 받는게 아니라, `직접 필요한 의존관계를 찾는 것`을 `Dependency Lookup(DL), 의존관계 조회(탐색)`이라 한다.

- 해결방법 2가지
  - `ObjectProvider` 사용 // `스프링 컨테이너`에서 사용 // 이걸 기본으로 쓰자. ✅
  - `JSR-330 Provider` 사용 // `다른 컨테이너`에서도 사용할 수 있어야 한다면 사용
  - 상황에 따라 사용하자.

### ✔️ 웹 스코프

- `request 스코프` 예제
  - 에러가 난다...
    - Error creating bean with name 'myLogger': Scope 'request' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton;
  - 왜?
    - 스프링 애플리케이션을 실행하는 시점에 `싱글톤 빈`은 생성해서 주입이 가능하지만, `request 스코프 빈`은 아직 생성되지 않는다.
    - `request 스코프 빈`은 실제 고객의 요청이 와야 생성할 수 있다!
  - 해결방법 2가지
    - `Provider` 사용 // 코드를 더 추가해야 한다. 귀찮...
    - `프록시` 사용 // 이걸 쓰자! ✅