# (복습) 스프링 핵심 원리 - 기본편 (요약)

## 서론

- 기존에 정리했던 내용: 
  - [(복습) 스프링 핵심 원리 - 기본편](spring_02_basic.md)
- 위 내용을 한번 더 요약하여 전체적인 흐름을 복습하고자 함.
  - 양이 방대하고 아직 내용이 내게 낯설어서 한눈에 안들어온다...
  - 큰 흐름을 잡고, 디테일한 것은 필요할 때 다시 찾아봐야겠다.

## 객체 지향 프로그래밍(OOP)

- 4가지 특징 : `추상화`, `캡슐화`, `상속`, `다형성`
  - `다형성`이 제일 중요하다.

## 객체 지향 설계의 5가지 원칙(SOLID)

- `SRP`: `단일 책임 원칙` (Single Responsibility Principle) ⭐
  - 한 클래스는 하나의 책임만 가져야 한다.
- `OCP`: `개방-폐쇄 원칙` (Open/closed principle) ⭐
  - 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
- `LSP`: `리스코프 치환 원칙` (Liskov substitution principle)
  - 하위 클래스는 상위 인터페이스 규약을 지켜야 한다.
- `ISP`: `인터페이스 분리 원칙` (Interface segregation principle)
  - 인터페이스를 작게 분리하면 더 좋다.
- `DIP`: `의존관계 역전 원칙` (Dependency inversion principle) ⭐
  - 구체화가 아닌, 추상화에 의존해야 한다.

## 왜 스프링?

- `자바`만으로는 `객체지향`의 핵심인 `다형성`을 구현하기에 `한계`가 있다.
  - 구현 객체를 변경할때 클라이언트의 코드도 함께 변경하게됨. (`OCP`,`DIP` 위반)
    - 예) `MemberService` 클라이언트가 구현 클래스를 직접 선택
      - `MemberRepository m = new MemoryMemberRepository();`
- `스프링`으로는 가능!
  - `스프링`은 `다형성`을 극대화해서 이용할 수 있게 도와준다.

## AppConfig (설정 정보)

- `AppConfig`: 애플리케이션의 전체 동작 방식을 구성하는 설정 클래스.
  - `공연`을 준비할 때, `배우`가 `상대방 배우`를 정하지 않는다.
    - `배우`는 배역을 수행하는 것에 집중 해야하고,
    - `공연기획자`가 공연을 구성하고, 역할에 맞는 배우를 지정한다.
  - `애플리케이션`에서 `AppConfig`가 `공연기획자` 역할을 한다.
    - `AppConfig`에서 구현 객체를 생성하고, 연결한다.
- `AppConfig`를 별도로 둔 덕분에 `OCP`,`DIP`, `SRP`를 지킬 수 있다.

## IoC (Inversion of Control, 제어의 역전)

- 프로그램의 `제어 흐름`을 `직접 제어`하는 것이 아니라 `외부에서 관리`하는 것.
  - `이전`: `직접 제어`
    - `구현 객체`가 프로그램의 제어 흐름을 스스로 조종했다.
  - `AppConfig` 등장 이후: `외부에서 관리`
    - `AppConfig`가 제어의 흐름을 가져간다.
    - `구현 객체`는 자신의 로직을 실행하는 역할만 담당한다.

## DI (Dependency Injection, 의존관계 주입)

- `런타임`에 `외부`에서 `구현 객체`를 생성하고 `클라이언트`에 전달해서, `클라이언트`와 `서버`의 실제 `의존관계`가 연결 되는 것.
  - (`외부` --> `클라이언트` --> `서버`)

## DI 컨테이너 (== AppConfig)

- `AppConfig`처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 `IoC 컨테이너` 또는 `DI 컨테이너`라 한다.
  - 최근에는 주로 `DI 컨테이너`라 한다.

## 스프링 컨테이너, 스프링 빈

- `ApplicationContext`를 `스프링 컨테이너`라 한다.
- `스프링 컨테이너`는 `@Configuration`이 붙은 `AppConfig`를 설정(구성) 정보로 사용한다.
  - 여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 `스프링 컨테이너`에 등록한다.
  - 이렇게 `스프링 컨테이너`에 등록된 객체를 `스프링 빈`이라 한다.
  - `스프링 빈`은 `@Bean`이 붙은 메서드의 명을 `스프링 빈`의 이름으로 사용한다.
- `스프링 컨테이너`를 통해서 필요한 `스프링 빈`(객체)를 찾아야 한다.
  - `스프링 빈`은 `applicationContext.getBean()` 메서드를 사용해서 찾을 수 있다.

## 싱글톤 패턴

- `클래스`의 `인스턴스`가 `딱 1개만 생성`되는 것을 보장하는 `디자인 패턴`이다.
  - `싱글톤 패턴`을 적용하면, 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.
- `자바`로만 `싱글톤 패턴`을 구현하면 여러 `문제점`들이 있다.
  - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
  - 테스트하기 어렵다.
  - 내부 속성을 변경하거나 초기화 하기 어렵다.
  - private 생성자로 자식 클래스를 만들기 어렵다.
- `스프링`의 `스프링 컨테이너`는 이 문제점들을 `해결`한다.

## 싱글톤 컨테이너

- `스프링 컨테이너`는 `싱글톤 패턴`의 문제점을 해결하면서, 객체 인스턴스를 `싱글톤`(1개만 생성)으로 관리한다.
  - `스프링 빈`이 바로 `싱글톤`으로 관리되는 `빈`이다.

## 싱글톤 방식의 주의점

- `싱글톤` 방식은 `여러 클라이언트`가 `하나의 같은 객체 인스턴스`를 공유하기 때문에 정말 `위험`하다.
- `스프링 빈`의 `필드`에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!!

## 컴포넌트 스캔

- `스프링`은 `설정 정보(AppConfig)`가 없어도 `자동으로 스프링 빈을 등록`하는 `컴포넌트 스캔` 기능을 제공한다.
  - `@Component` 애노테이션이 붙은 클래스를 스캔해서 `스프링 빈`으로 등록.

## 의존관계 자동 주입

- `스프링`은  `의존관계도 자동으로 주입`하는 `@Autowired`라는 기능도 제공한다.

- `의존관계 주입`은 크게 4가지 방법이 있다.
  - `생성자 주입` // 이거 쓰자!!
  - `수정자 주입`(`setter 주입`) // 가끔 필요할때만 사용하자.
  - `필드 주입` // 사용 x
  - `일반 메서드 주입` // 사용 x

## 롬복(Lombok)

- `Lombok`을 사용하면, 적용한 `애노테이션`에 따라서 해당 기능을 자동으로 만들어준다. 
  - `@Getter`
  - `@Setter`
  - `@NoArgsConstructor`: 생성자
  - `@ToString`
  - `@RequiredArgsConstructor`: 롬복이 `final`로 되어있는 필드를 보고 자동으로 생성자를 만들어준다.
- 실무에서 많이 쓴다!!
- 사용하려면, `인텔리제이`에 롬복 설치하고, `build.gradle`에 라이브러리 & 환경 추가 해야한다.